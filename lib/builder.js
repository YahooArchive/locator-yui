/*
 * Copyright (c) 2013, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 */

/*jslint node: true, nomen: true */

'use strict';

var libfs = require('fs'),
    libpath = require('path'),
    utils = require('./utils'),
    expander = require('./expander'),
    debug = require('debug')('locator:yui'),
    TEMPLATE_TOKEN = '{ /* METAGEN */ }';

function BuilderClass(options) {
    this.name = options.name;
    this.group = options.group;
    this.data = {
        json: {},
        conds: {},
        files: null,
        mods: []
    };
}

BuilderClass.prototype = {
    compile: function (mods) {
        this.process(mods);
        this.expand();
        this.produceJSON();
        this.conditionals();
        this.produceJS();
    },
    process: function (mods) {
        var self = this;
        Object.keys(mods).forEach(function (key) {
            var mod = mods[key],
                i;
            for (i in mod.builds) {
                if (mod.builds.hasOwnProperty(i)) {
                    self.parseData(i, mod.builds[i].config || {}, mod.buildfile);
                }
            }
        });
    },
    parseData: function (name, data, file) {
        var i, o;
        for (i in data) {
            if (data.hasOwnProperty(i)) {
                if (i === 'submodules' || i === 'plugins') {
                    for (o in data[i]) {
                        if (data[i].hasOwnProperty(o)) {
                            this.parseData(o, data[i][o], file);
                        }
                    }
                    delete data[i];
                }
                if (i === 'condition') {
                    if (data[i].test && (utils.isFunction(data[i].test) || libpath.extname(data[i].test) === '.js')) {
                        this.data.conds[name] = data[i].test;
                    }
                    data[i].name = name;
                    data[i] = this.sortObject(data[i]);
                }
            }
        }
        if (this.group) {
            data.group = this.group;
        }
        if (this.data.json[name]) {
            debug("Module name collision: an existing module with name '%s' is being overruled by a module described in file '%s'", name, file);
        }
        this.data.json[name] = this.sortObject(data);
    },
    sortObject: function (data) {
        var keys = Object.keys(data).sort(),
            d = {};
        keys.forEach(function (k) {
            d[k] = data[k];
        });
        return d;
    },
    expand: function () {
        var self = this;
        Object.keys(this.data.json).forEach(function (name) {
            var mod = self.data.json[name];
            if (!mod.condition) {
                self.data.json[name] = expander(name, mod);
            }
        });
    },
    conditionals: function () {
        var tests = [],
            allTests = [],
            jsonStr,
            self = this;

        Object.keys(this.data.json).forEach(function (name) {
            var mod = self.data.json[name],
                cond,
                cName,
                test;
            if (mod.condition) {
                cond = self.sortObject(mod.condition);
                if (self.data.conds[mod.condition.name]) {
                    cName = mod.condition.name;
                    test = self.data.conds[cName];
                    if (test && utils.isFunction(test)) {
                        mod.condition.test = utils.md5(mod.condition.name);
                        cond.test = test.toString();
                        tests.push({ key: mod.condition.test, test: cond.test });
                    } else if (libfs.existsSync(test)) {
                        mod.condition.test = utils.md5(mod.condition.name);
                        // TODO: make this async and remove the stupid flag
                        cond.test = test = libfs.readFileSync(test, 'utf8');
                        tests.push({ key: mod.condition.test, test: cond.test });
                    } else {
                        throw new Error('Failed to locate test file: ' + test);
                    }
                }
                allTests.push(cond);
            }
        });

        jsonStr = JSON.stringify(this.data.json, null, 4);

        tests.forEach(function (info) {
            jsonStr = jsonStr.replace('"' + info.key + '"', info.test);
        });

        jsonStr = jsonStr.replace(/\}\n,/g, '},').replace(/\}\n\n,/g, '},');

        this.data.jsonStr = jsonStr;
        this.data.tests = allTests;

    },
    produceJSON: function () {
        this.data.json = this.sortObject(this.data.json);
    },
    produceJS: function () {
        this.data.js = this.header().replace(TEMPLATE_TOKEN, this.data.jsonStr);
    },
    header: function () {
        var str = [
            '/* This file is auto-generated by locator plugin express-yui for bundle ' + this.group + ' */',
            '',
            '/*jshint maxlen:900, eqeqeq: false */',
            '',
            '/**',
            ' * YUI 3 module metadata',
            ' * @module ' + this.name,
            ' */'
        ];

        str.push('YUI.Env[Y.version].modules = YUI.Env[Y.version].modules || {};');
        str.push('Y.mix(YUI.Env[Y.version].modules, { /* METAGEN */ });');

        str.unshift('YUI.add("' + this.name + '", function(Y, NAME) {');
        str.push('}, "", {requires: ["loader-base"]});');

        return str.join('\n');
    }
};

module.exports = BuilderClass;
